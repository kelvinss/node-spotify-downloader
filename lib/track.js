// Generated by CoffeeScript 1.10.0
(function() {
  var AlreadyDownloadedError, EventEmitter, Logger, Path, Track, async, cleanEmptyDirs, clone, deepMap, domain, fixPathPiece, fs, getSpotID, id3, makeB64, mkdirp, objTypeof, process, ref, removeFile, request, sformat,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  process = require("process");

  async = require("async");

  fs = require("fs");

  mkdirp = require("mkdirp");

  id3 = require("node-id3");

  domain = require("domain");

  EventEmitter = require("events").EventEmitter;

  request = require("request");

  Path = require("path");

  Logger = require("./log");

  Logger = new Logger();

  clone = require("clone");

  sformat = require("string-format");

  ref = require("./util"), cleanEmptyDirs = ref.cleanEmptyDirs, removeFile = ref.removeFile, makeB64 = ref.makeB64, objTypeof = ref.objTypeof, deepMap = ref.deepMap, fixPathPiece = ref.fixPathPiece, getSpotID = ref.getSpotID;

  AlreadyDownloadedError = (function() {
    function AlreadyDownloadedError() {}

    return AlreadyDownloadedError;

  })();

  Track = (function() {
    var handleAsyncError, padDigits;

    function Track(uri, config, data, callback1) {
      this.uri = uri;
      this.config = config;
      this.data = data;
      this.callback = callback1;
      this.writeMetadata = bind(this.writeMetadata, this);
      this.closeStream = bind(this.closeStream, this);
      this.downloadFile = bind(this.downloadFile, this);
      this.downloadCover = bind(this.downloadCover, this);
      this.cleanDirs = bind(this.cleanDirs, this);
      this.handleFs = bind(this.handleFs, this);
      this.formatPath = bind(this.formatPath, this);
      this.handle = bind(this.handle, this);
      this.process = bind(this.process, this);
      this.track = {};
      this.file = {};
      this.retryCounter = 0;
    }

    Track.setSpotify = function(spotify) {
      Track.spotify = spotify;
    };

    Track.init = function() {
      return process.on("SIGINT", function() {
        var ref1, ref2, tasks;
        Logger.Log("\nCLOSING [SIGINT]");
        tasks = [(ref1 = Track.cur) != null ? ref1.closeStream : void 0, (ref2 = Track.cur) != null ? ref2.cleanDirs : void 0].map(function(f) {
          return f != null ? f : function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          };
        });
        return async.series(tasks, function(err) {
          if (err) {
            Logger.Error("Error while closing: " + err);
          } else {
            Logger.Success("-- CLEANED --");
          }
          return process.exit(0);
        });
      });
    };

    handleAsyncError = function(func) {
      return function() {
        var err, error;
        try {
          return func.apply(this, arguments);
        } catch (error) {
          err = error;
          return typeof arguments[0] === "function" ? arguments[0](err) : void 0;
        }
      };
    };

    Track.prototype.process = function() {
      Track.cur = this;
      return this.constructor.spotify.get(this.uri, (function(_this) {
        return function(err, track) {
          if (err) {
            return typeof _this.callback === "function" ? _this.callback(err) : void 0;
          }
          _this.track = track;
          return _this.handle();
        };
      })(this));
    };

    Track.prototype.handle = function() {
      Logger.Log("Downloading: " + this.track.artist[0].name + " - " + this.track.name, 1);
      return async.series([this.formatPath, this.handleFs, this.downloadFile, this.downloadCover, this.writeMetadata], (function(_this) {
        return function(err, res) {
          if (err) {
            if (err instanceof AlreadyDownloadedError) {
              Logger.Info("Already downloaded: " + _this.track.artist[0].name + " - " + _this.track.name, 2);
            } else {
              Logger.Error("Error on track: \"" + _this.track.artist[0].name + " - " + _this.track.name + "\" : " + err.stack, 1);
              return _this.cleanDirs(_this.callback);
            }
          }
          return typeof _this.callback === "function" ? _this.callback() : void 0;
        };
      })(this));
    };

    Track.prototype.formatPath = function() {};

    Track.prototype.formatPath = handleAsyncError(function(callback) {
      var _path, err, error, fields, fixStrg, i, j, len, len1, o, pathFormat, ref1, ref2, ref3, ref4, trackCopy;
      this.config.directory = Path.resolve(this.config.directory);
      if (this.config.folder && typeof this.config.folder === "string") {
        if (this.config.folder === "legacy") {
          pathFormat = "{artist.name}/{album.name} [{album.year}]/{artist.name} - {track.name}";
        } else {
          pathFormat = this.config.folder;
        }
      } else {
        pathFormat = "{artist.name} - {track.name}";
      }
      trackCopy = clone(this.track);
      trackCopy.name = trackCopy.name.replace(/\//g, " - ");
      fixStrg = (function(_this) {
        return function(obj) {
          if (objTypeof(obj) === "[object String]") {
            obj = obj.replace(/\//g, "-");
            if (_this.config.onWindows) {
              obj = fixPathPiece(obj);
            }
          }
          return obj;
        };
      })(this);
      deepMap.call({
        fn: fixStrg
      }, trackCopy);
      ref1 = [trackCopy, trackCopy.album].concat(trackCopy.artist);
      for (i = 0, len = ref1.length; i < len; i++) {
        o = ref1[i];
        o.id = getSpotID(o.uri);
      }
      ref2 = [trackCopy, trackCopy.album].concat(trackCopy.artist);
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        o = ref2[j];
        o.b64uri = makeB64(o.uri);
      }
      fields = {
        track: trackCopy,
        artist: trackCopy.artist[0],
        album: trackCopy.album,
        playlist: {}
      };
      fields.album.year = fields.album.date.year;
      if ((ref3 = this.data.type) === "album" || ref3 === "playlist" || ref3 === "library") {
        fields.playlist.name = this.data.name;
        fields.playlist.uri = this.data.uri;
        fields.playlist.id = this.data.id;
        fields.playlist.b64uri = this.data.b64uri;
      }
      if ((ref4 = this.data.type) === "playlist" || ref4 === "library") {
        fields.index = fields.track.index = padDigits(this.data.index, String(this.data.trackCount).length);
        fields.playlist.trackCount = this.data.trackCount;
        fields.playlist.user = this.data.user;
      }
      fields.id = this.data.id;
      fields.b64uri = this.data.b64uri;
      fields.user = this.config.username;
      try {
        _path = sformat(pathFormat, fields);
      } catch (error) {
        err = error;
        Logger.Error("Invalid path format: " + err, 1);
        return typeof callback === "function" ? callback(err) : void 0;
      }
      if (!_path.endsWith(".mp3")) {
        _path += ".mp3";
      }
      this.file.path = Path.join(this.config.directory, _path);
      this.file.directory = Path.dirname(this.file.path);
      return typeof callback === "function" ? callback(err) : void 0;
    });

    Track.prototype.handleFs = function() {};

    Track.prototype.handleFs = handleAsyncError(function(callback) {
      var stats;
      if (fs.existsSync(this.file.path)) {
        stats = fs.statSync(this.file.path);
        if (stats.size !== 0) {
          return typeof callback === "function" ? callback(new AlreadyDownloadedError()) : void 0;
        }
      }
      if (!fs.existsSync(this.file.directory)) {
        mkdirp.sync(this.file.directory);
      }
      return typeof callback === "function" ? callback() : void 0;
    });

    Track.prototype.cleanDirs = function(callback) {
      if (this.file.path) {
        return async.map([this.file.path, this.file.path + ".jpg"], removeFile, (function(_this) {
          return function(err) {
            if (err) {
              return typeof callback === "function" ? callback(err) : void 0;
            } else {
              return cleanEmptyDirs(_this.file.directory, callback);
            }
          };
        })(this));
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    Track.prototype.downloadCover = function() {};

    Track.prototype.downloadCover = handleAsyncError(function(callback) {
      var coverPath, coverUrl, image, images, ref1, ref2;
      coverPath = this.file.path + ".jpg";
      images = (ref1 = this.track.album.coverGroup) != null ? ref1.image : void 0;
      image = (ref2 = images != null ? images[2] : void 0) != null ? ref2 : images != null ? images[0] : void 0;
      if (!image) {
        Logger.Error("Can't download cover: " + this.track.artist[0].name + " - " + this.track.name, 2);
        return typeof callback === "function" ? callback(null, this.hasCover = false) : void 0;
      }
      coverUrl = "" + image.uri;
      return request.get(coverUrl).on("error", (function(_this) {
        return function(err) {
          Logger.Error("Error while downloading cover: " + err);
          return typeof callback === "function" ? callback(null, _this.hasCover = false) : void 0;
        };
      })(this)).pipe(fs.createWriteStream(coverPath)).on("finish", (function(_this) {
        return function() {
          Logger.Success("Cover downloaded: " + _this.track.artist[0].name + " - " + _this.track.name, 2);
          return typeof callback === "function" ? callback(null, _this.hasCover = true) : void 0;
        };
      })(this));
    });

    Track.prototype.downloadFile = function() {};

    Track.prototype.downloadFile = handleAsyncError(function(_callback) {
      var callback, func, handleError, retries, retryTime;
      retries = 2;
      retryTime = 10000;
      callback = function() {
        if (_callback != null) {
          _callback.apply(null, arguments);
        }
        return callback = function() {};
      };
      handleError = (function(_this) {
        return function(err) {
          if (("" + err).indexOf("Rate limited") > -1) {
            Logger.Error("Error received: " + err, 2);
            if (_this.retryCounter < retries) {
              _this.retryCounter++;
              Logger.Info("{ Retrying in " + (retryTime / 1000) + " seconds }", 2);
              return setTimeout(func, retryTime);
            } else {
              Logger.Error("Unable to download song: " + err + ". Continuing", 2);
              return typeof callback === "function" ? callback(err) : void 0;
            }
          } else {
            Logger.Error("Error while downloading track: " + err, 2);
            return typeof callback === "function" ? callback(err) : void 0;
          }
        };
      })(this);
      func = (function(_this) {
        return function() {
          var err, error;
          try {
            _this.out = fs.createWriteStream(_this.file.path);
            _this.strm = _this.track.play();
            _this.strm.on("error", handleError);
            return _this.strm.pipe(_this.out).on("finish", function() {
              Logger.Success("Downloaded: " + _this.track.artist[0].name + " - " + _this.track.name, 2);
              return typeof callback === "function" ? callback() : void 0;
            });
          } catch (error) {
            err = error;
            return handleError(err);
          }
        };
      })(this);
      return func();
    });

    Track.prototype.closeStream = function() {};

    Track.prototype.closeStream = handleAsyncError(function(_callback) {
      var callback;
      callback = function() {
        _callback.apply(null, arguments);
        return callback = function() {};
      };
      if (this.strm) {
        this.out.on("unpipe", (function(_this) {
          return function() {
            return typeof callback === "function" ? callback() : void 0;
          };
        })(this));
        return this.strm.on("error", callback).unpipe(this.out);
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    });

    Track.prototype.writeMetadata = function() {};

    Track.prototype.writeMetadata = handleAsyncError(function(callback) {
      var meta;
      meta = {
        artist: this.track.artist[0].name,
        album: this.track.album.name,
        title: this.track.name,
        year: "" + this.track.album.date.year,
        trackNumber: "" + this.track.number
      };
      if (this.hasCover) {
        meta.image = this.file.path + ".jpg";
      }
      id3.write(meta, this.file.path);
      if (this.hasCover) {
        removeFile(meta.image);
      }
      return typeof callback === "function" ? callback() : void 0;
    });

    padDigits = function(number, digits) {
      return Array(Math.max(digits - String(number).length + 1, 0)).join(0) + number;
    };

    return Track;

  })();

  module.exports = Track;

}).call(this);
